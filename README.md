# Лабораторная работа 22

## Оптимизация SQL‑запросов: Hill Climbing, Beam Search, имитация отжига

В этой лабораторной работе реализуются три алгоритма оптимизации SQL‑запросов.
Каждый алгоритм ищет лучший план соединения (JOIN) и использования индексов для
заданного числа таблиц.  Оценка плана выполняется в рамках синтетической
модели: задаётся «идеальный» порядок соединений и использование индексов,
а стоимость плана зависит от расхождения с этим идеалом.  Метрики,
возвращаемые моделью, отражают производительность, количество индексов и
сложность соединения; чем выше метрика, тем лучше.

### Реализованные алгоритмы

- **Hill Climbing (HC)** — находит очевидные улучшения плана, улучшая одну
  метрику (производительность) до локального максимума.  Подходит для
  быстрого нахождения простых оптимизаций.
- **Beam Search (BS)** — одновременно рассматривает несколько кандидатов,
  балансируя производительность, использование индексов и сложность.
  Перебирает разные варианты порядка JOIN и индексов, отбирая лучшие.
- **Имитация отжига (SA)** — исследует неочевидные перестановки, позволяя
  принимать ухудшающие решения при высокой температуре.  Это позволяет
  выходить из локальных максимумов и находить более качественные планы.

### Сборка и запуск

Для сборки проекта требуется `cmake` и компилятор с поддержкой C++17.  В
терминале выполните:

```bash
rm -rf build && cmake -B build && cmake --build build && ./build/sql_query_optimizer
```

Программа сгенерирует случайный стартовый план и применит к нему три
алгоритма.  На выходе вы увидите стартовый и оптимальные планы, а также
соответствующие метрики.

### Структура проекта

```
lab22/
│── include/
│   └── query_opt.h         # объявление структур и функций
│
│── src/
│   ├── query_model.cpp     # модель оценки и генерация планов
│   ├── algorithms.cpp      # реализация HC, Beam Search и SA
│   └── main.cpp            # точка входа и демонстрация алгоритмов
│
└── CMakeLists.txt          # конфигурация сборки
```

### Использование

Код можно адаптировать под реальные источники данных или интегрировать с
оптимизаторами SQL.  Текущая реализация использует искусственную функцию
стоимости, но алгоритмы остаются актуальными для задач оптимизации
запросов.
